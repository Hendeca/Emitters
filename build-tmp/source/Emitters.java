import processing.core.*; 
import processing.data.*; 
import processing.event.*; 
import processing.opengl.*; 

import java.util.HashMap; 
import java.util.ArrayList; 
import java.io.File; 
import java.io.BufferedReader; 
import java.io.PrintWriter; 
import java.io.InputStream; 
import java.io.OutputStream; 
import java.io.IOException; 

public class Emitters extends PApplet {

int i = 0; // For looping
Emitter[] emitters;

public void setup() {
  frameRate(29.97f);
  size(2560, 1440);
  background(0);
  emitters = new Emitter[20];
  initEmitters();
}

public void initEmitters() {
  for ( i = 0; i < emitters.length; i++) {
   
    emitters[i] = new Emitter(new PVector(0, 0), new PVector(random(-0.02f, 0.02f),0), new PVector(0, 0), new PVector(3.0f,3.0f), new PVector(1.0f, 1.0f), new PVector(0.02f, 0.02f), new PVector(0.1f, 0.1f), random(0.995f, 0.999f), 0.06f, 22.5f, new ColorCycle(random(0.4f, 0.8f), 0, 2, 4, random(20, 50)));
  
  }
}

public void draw() {
  background(0);
  for ( i = 0; i < emitters.length; i++) {
    pushMatrix();
    translate(width / 2, height / 2);
    emitters[i].update();
    emitters[i].draw();
    popMatrix();
    //saveFrame("RainbowPartSmall/frames######.png");
  }  
}
class ColorCycle {
  
  int i = 0;
  float freq, oR, oG, oB, a;
  float[] rgbArray = new float[4];
  
  ColorCycle(float frequency, float offsetRed, float offsetGreen, float offsetBlue, float alpha) {
    freq = frequency;
    oR = offsetRed;
    oG = offsetGreen;
    oB = offsetBlue;
    a = alpha;
  }
  
  ColorCycle() {
    freq = 1;
    oR = 0;
    oG = 2;
    oB = 4;
    a = 255;
  }
  
  public float[] update() {
    rgbArray[0] = ((sin(radians(freq * i) + oR)) * 127) + 128;
    rgbArray[1] = ((sin(radians(freq * i) + oG)) * 127) + 128;
    rgbArray[2] = ((sin(radians(freq * i) + oB)) * 127) + 128;
    rgbArray[3] = a;
    i += 1;
    return rgbArray;
  }
}
class Emitter {

  int savedTime, // Used to detect how many milliseconds have passed
      i;
  float frequency, // Frequency in milliseconds with which the Emitter spits out a particle
        friction,
        angleDivisor,
        fadeRate = 0,
        t;
  PVector position, // The x and y coordinates of the Emitter
          velocity, // The velocity in pixels per frame
          acceleration, // The acceleration in pixels per frame squared
          velSD, // The standard deviation for the velocity
          velMean, // Mean of the veloctity. Same deal for all following PVector declarations
          accelSD,
          accelMean;
  ArrayList<Particle> particles = new ArrayList<Particle>(); // Dynamic array of all active particles
  float[] colorVals; // To store the RGBA color values generated by the ColorCycle
  ColorCycle cycle; // Color cycle to change the colors of the particles
  
  Emitter(PVector position_, PVector velocity_, PVector acceleration_, PVector velSD_, PVector velMean_, PVector accelSD_, PVector accelMean_, float friction_, float frequency_, float angleDivisor_, ColorCycle cycle_) {
    position = position_;
    velocity = velocity_;
    acceleration = acceleration_;
    angleDivisor = angleDivisor_;
    frequency = frequency_;
    velSD = velSD_;
    velMean = velMean_;
    accelSD = accelSD_;
    accelMean = accelMean_;
    friction = friction_;
    cycle = cycle_;
    colorVals = cycle.update();
    savedTime = millis();

  }
  
  public void draw() {

    if(particles.size() > 0) {

      for(i = particles.size() - 1; i != 0; i--) {
      
        Particle particle = particles.get(i);

        if(particle.position.x > (width / 2) || particle.position.x < (width / -2)) {
          particles.remove(i);
        }

        if(particle.position.y > (height / 2) || particle.position.y < (height / -2)) {
          particles.remove(i);
        }
        pushMatrix();
        translate(position.x, position.y);
        particle.update();
        particle.oscillate();
        particle.draw();
        popMatrix();
      }

    }
      
    t += 0.1f;
  }
  
  public void update() {
    
    velocity.add(acceleration);
    position.add(velocity);
    int passedTime = millis() - savedTime;
    if( passedTime >= frequency) {
        emitParticle();
        savedTime = millis();
    }
  }
  
  public void emitParticle() {
      float pVelocity = random(8.1f, 10);
      float pAcceleration = random(-0.02f, 0.02f);
      float pFriction = friction;
      float period = 20;
      float amplitude = 10;
      float angle = round(random(-180, 180) / angleDivisor) * angleDivisor;
      fadeRate = 10;
      int strokeWeight = (int)random(8, 10);
      
      colorVals = cycle.update();

      particles.add(new Particle(new PVector(0, 0), pVelocity, pAcceleration, angle, fadeRate, period, amplitude, pFriction, colorVals, strokeWeight));
  }
}
class Particle {

  int strokeWeight,
      t = 0;
  PVector position,
          velocity,
          sineVel;
  float friction,
        frequency,
        period,
        amplitude,
        angle,
        acceleration,
        fadeRate;
  float[] particleColors;
  
  Particle(PVector position_, float velocity_, float acceleration_, float angle_, float fadeRate_, float period_, float amplitude_, float friction_, float[] particleColors_, int strokeWeight_) {
    
    particleColors = particleColors_;
    strokeWeight = strokeWeight_;
    position = position_;
    angle = angle_;
    velocity = new PVector(velocity_ * sin(angle), velocity_ * cos(angle));
    acceleration = acceleration_;
    fadeRate = fadeRate_;
    friction = friction_;
    period = period_;
    amplitude = amplitude_;
  }
  
  public void draw() {
    pushMatrix();
    strokeWeight(strokeWeight);
    translate(position.x, position.y);
    fade();
    stroke(particleColors[0], particleColors[1], particleColors[2], particleColors[3]);
    point(0, 0);
    popMatrix();
    t++;
  }
  
  public void update() {

    position.add(velocity);
    if(friction > 0) {
      position.mult(friction);
    }
    
  }

  public void oscillate() {

    frequency = 1 / period;
    sineVel = new PVector((amplitude * (sin((angle + 90)))) * sin(t * frequency) , (amplitude * (cos((angle + 90)))) * sin(t * frequency));
    position.add(sineVel);

  }

  public void fade() {

    if(particleColors[3] <= 30) {
      particleColors[3] = 30;
      fadeRate *= -1;
    }

    if(particleColors[3] >= 200) {
      particleColors[3] = 200;
      fadeRate *= -1;
    }

    particleColors[3] -= fadeRate;

  }

  public void updateColor(float[] particleColors_) {

    particleColors = particleColors_;

  }
}
  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Emitters" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
