class Emitter {

  int savedTime, // Used to detect how many milliseconds have passed
      i;
  float frequency, // Frequency in milliseconds with which the Emitter spits out a particle
        friction,
        angleDivisor,
        fadeRate = 0,
        t;
  PVector position, // The x and y coordinates of the Emitter
          velocity, // The velocity in pixels per frame
          acceleration, // The acceleration in pixels per frame squared
          velSD, // The standard deviation for the velocity
          velMean, // Mean of the veloctity. Same deal for all following PVector declarations
          accelSD,
          accelMean;
  ArrayList<Particle> particles = new ArrayList<Particle>(); // Dynamic array of all active particles
  float[] colorVals; // To store the RGBA color values generated by the ColorCycle
  ColorCycle cycle; // Color cycle to change the colors of the particles
  
  Emitter(PVector position_, PVector velocity_, PVector acceleration_, PVector velSD_, PVector velMean_, PVector accelSD_, PVector accelMean_, float friction_, float frequency_, float angleDivisor_, ColorCycle cycle_) {
    position = position_;
    velocity = velocity_;
    acceleration = acceleration_;
    angleDivisor = angleDivisor_;
    frequency = frequency_;
    velSD = velSD_;
    velMean = velMean_;
    accelSD = accelSD_;
    accelMean = accelMean_;
    friction = friction_;
    cycle = cycle_;
    colorVals = cycle.update();
    savedTime = millis();

  }
  
  void draw() {

    if(particles.size() > 0) {

      for(i = particles.size() - 1; i != 0; i--) {
      
        Particle particle = particles.get(i);

        if(particle.position.x > (width / 2) || particle.position.x < (width / -2)) {
          particles.remove(i);
        }

        if(particle.position.y > (height / 2) || particle.position.y < (height / -2)) {
          particles.remove(i);
        }
        pushMatrix();
        translate(position.x, position.y);
        particle.update();
        particle.oscillate();
        particle.draw();
        popMatrix();
      }

    }
      
    t += 0.1;
  }
  
  void update() {
    
    velocity.add(acceleration);
    position.add(velocity);
    int passedTime = millis() - savedTime;
    if( passedTime >= frequency) {
        emitParticle();
        savedTime = millis();
    }
  }
  
  void emitParticle() {
      float pVelocity = random(8.1, 10);
      float pAcceleration = random(-0.02, 0.02);
      float pFriction = friction;
      float period = 20;
      float amplitude = 10;
      float angle = round(random(-180, 180) / angleDivisor) * angleDivisor;
      fadeRate = 10;
      int strokeWeight = (int)random(8, 10);
      
      colorVals = cycle.update();

      particles.add(new Particle(new PVector(0, 0), pVelocity, pAcceleration, angle, fadeRate, period, amplitude, pFriction, colorVals, strokeWeight));
  }
}