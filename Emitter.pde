class Emitter {

  int savedTime = millis(),
      i; // For looping
  float emitRate, // Frequency in milliseconds with which the Emitter spits out a particle
        friction, // Friction acting on the Emitter
        angleDivisor, // Emits particles at angles divisble by angleDivisor
        t, // Time
        fadeRate = 40, // Rate at which particles will fade in and out
        pStartOpacity = 255; // Starting opacity of Particles
  PVector position, // The x and y coordinates of the Emitter
          velocity, // The velocity in pixels per frame
          acceleration; // The acceleration in pixels per frame squared
  ArrayList<Particle> particles = new ArrayList<Particle>(); // Dynamic array of all active particles
  float[] pColorVals; // To store the RGBA color values generated by the ColorCycle
  ColorCycle cycle = new ColorCycle(random(0.5, 0.6), 0, 2, 4, 255); // Color cycle to change the colors of the particles
  
  Emitter(PVector position_, PVector velocity_, PVector acceleration_, float friction_, float emitRate_, float angleDivisor_) {

    // Set class variables after instantiation
    position = position_;
    velocity = velocity_;
    acceleration = acceleration_;
    angleDivisor = angleDivisor_;
    emitRate = emitRate_;
    friction = friction_;
    pColorVals = cycle.update();
    savedTime = millis();
  }
  
  void draw() {

    // Check to see if any particles have been created
    if(particles.size() > 0) {

      // If particles have been created, loop through all particles in reverse
      // This is necessary of ListArrays when removing elements
      for(i = particles.size(); i-- != 0;) {
      
        // Get the current Particle
        Particle particle = particles.get(i);

        // If the Particle is off of the screen, remove it
        if(particle.position.x > (width / 2) || particle.position.x < (width / -2)) {
          particles.remove(i);
        }

        if(particle.position.y > (height / 2) || particle.position.y < (height / -2)) {
          particles.remove(i);
        }

        // Translate matrix to the center of the screen, update and draw Particles
        pushMatrix();
        translate(position.x, position.y);
        particle.update();
        particle.fade();
        particle.draw();
        popMatrix();

      }

    }
    
    // Increment time
    t += 0.1;
  }
  
  void update() {
    
    // Update position of this Emitter
    velocity.add(acceleration);
    position.add(velocity);

    // Check to see if enough time has passed to emit another Particle
    int passedTime = millis() - savedTime;
    if( passedTime >= emitRate) {

        // Emit new particle and reset the clock
        emitParticle();
        savedTime = millis();
    }
  }
  
  void emitParticle() {

      // Set variables for the Particle to be instantiated
      float pVelocity = random(6, 8);
      float pAcceleration = random(-0.02, 0.02);
      float pFriction = friction;
      float pPeriod = 1;
      float pAmplitude = 7;
      float pAngle = angleDivisor;
      float pFadeRate = 1;

      int pStrokeWeight = (int)random(3, 8);
      
      pColorVals = cycle.update();
      pColorVals[3] = pStartOpacity;

      // Create a new Particle and send it out into the world!
      particles.add(new Particle(new PVector(0, 0), pVelocity, pAcceleration, pAngle, pFadeRate, pPeriod, pAmplitude, pFriction, pColorVals, pStrokeWeight));
  }
}